{
    "version": "https://jsonfeed.org/version/1",
    "title": "红玉のblog • All posts by \"学习笔记\" category",
    "description": "",
    "home_page_url": "https://zeroruby.github.io",
    "items": [
        {
            "id": "https://zeroruby.github.io/2023/10/25/Unity%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "https://zeroruby.github.io/2023/10/25/Unity%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "Unity插件制作学习笔记",
            "date_published": "2023-10-24T16:00:00.000Z",
            "content_html": "<p>记录自己学习 unity 制作插件时的细节和 tips，有任何问题或疑惑请随时通过主页联系方式联系我一起探讨。</p>\n<span id=\"more\"></span>\n<hr>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E4%B8%80-%E8%87%AA%E5%AE%9A%E4%B9%89inspector%E7%95%8C%E9%9D%A2\">一、自定义 Inspector 界面</a>\n<ul>\n<li><a href=\"#1-%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3%E6%A0%87%E8%AF%86\">1、属性相关标识</a></li>\n<li><a href=\"#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%95%8C%E9%9D%A2%E5%B1%9E%E6%80%A7\">2、自定义界面属性</a></li>\n<li><a href=\"#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E5%B1%9E%E6%80%A7%E5%AD%97%E6%AE%B5\">3、自定义序列化属性字段</a></li>\n<li><a href=\"#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C%E7%95%8C%E9%9D%A2\">4、自定义操作界面</a>\n<ul>\n<li><a href=\"#a-%E7%95%8C%E9%9D%A2%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD\">a、界面的启动和关闭</a></li>\n<li><a href=\"#b-%E7%95%8C%E9%9D%A2%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3\">b、界面的事件相关</a></li>\n<li><a href=\"#c-%E6%96%87%E6%9C%AC%E9%A2%9C%E8%89%B2%E5%AD%97%E6%AE%B5\">c、文本 / 颜色字段</a></li>\n<li><a href=\"#d-%E6%A0%87%E7%AD%BE%E5%AD%97%E6%AE%B5\">d、标签字段</a></li>\n<li><a href=\"#e-%E8%BE%93%E5%85%A5%E5%AD%97%E6%AE%B5\">e、输入字段</a></li>\n<li><a href=\"#f-%E6%BB%91%E5%8A%A8%E6%9D%A1\">f、滑动条</a></li>\n<li><a href=\"#g-vector%E8%BE%93%E5%85%A5%E5%AD%97%E6%AE%B5\">g、Vector 输入字段</a></li>\n<li><a href=\"#h-%E9%80%89%E6%8B%A9\">h、选择</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<hr>\n<h1><span id=\"一-自定义-inspector-界面\"> 一、自定义 Inspector 界面</span></h1>\n<h2><span id=\"1-属性相关标识\"> 1、属性相关标识</span></h2>\n<p>5 种变量在 inspector 隐藏和显示的方法</p>\n<pre><code class=\"language-c#\">using System;\n\npublic class Value : MonoBehaviour\n&#123;\n    \n    public int int1;  \n\n    [HideInInspector]//直接隐藏在inspector  \n    public int int2=3;  \n\n    [NonSerialized]//隐藏的同时不会保存被inspector序列化后的值   \n    public int int3=3;//即更改inspector的值不会影响脚本的初始赋值  \n\n    [SerializeField]//将私有变量显示在inspector  \n    private int int4;  \n\n    public ValueTest valueTest = new ValueTest();  \n\n&#125;\n\n[Serializable]//可让自定义的类显示在inspector  \npublic class ValueTest   \n&#123;\n    public int int5;  \n&#125;\n</code></pre>\n<p>最终在 inspector 的表现效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231025225218480.png\" alt=\"image-20231025225218480\"></p>\n<h2><span id=\"2-自定义界面属性\"> 2、自定义界面属性</span></h2>\n<p>创建自定义界面需要在 Asset 路径下创建名为 Editor 的文件夹，此命名的文件夹打包时不会被打包（Resources 文件夹同理，在 load 方法加载资源时要注意路径<a href=\"https://docs.unity.cn/cn/2019.3/ScriptReference/Resources.Load.html\">（Resources-Load - Unity 脚本 API）</a>）</p>\n<p>创建上述 Value 的自定义 inspector：</p>\n<p>第一步：创建继承 Editor 基类的脚本，并将其放在 Editor 文件夹下，并声明是 Value 的界面</p>\n<pre><code class=\"language-c#\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\n[CustomEditor(typeof(Value))]\npublic class ValueEditor :Editor\n&#123;\n  \n    public SerializedObject mObj;   //定义序列化目标对象\n    //序列化出来几个属性\n    //属性对应的是[CustomEditor(typeof(Value))]中，Value类里面的属性\n\n    public SerializedProperty int1;\n    public SerializedProperty int2;\n    public SerializedProperty int3;\n    public SerializedProperty int4;\n    public SerializedProperty valueTest;\n\n    //选择当前游戏对象\n    private void OnEnable()\n    &#123;\n        //初始化\n        this.mObj = new SerializedObject(target);\n        //通过字符串名字，查找Test1类里面的属性，并进行初始化\n        this.int1 = this.mObj.FindProperty(&quot;int1&quot;);\n        this.int2 = this.mObj.FindProperty(&quot;int2&quot;);\n        this.int3 = this.mObj.FindProperty(&quot;int3&quot;);\n        this.int4 = this.mObj.FindProperty(&quot;int4&quot;);\n        this.valueTest = this.mObj.FindProperty(&quot;valueTest&quot;);\n    &#125;\n\n    //绘制\n    public override void OnInspectorGUI()\n    &#123;\n        this.mObj.Update();\n\n        EditorGUILayout.PropertyField(this.int1);\n        EditorGUILayout.PropertyField(this.int2);\n        //EditorGUILayout.PropertyField(this.int3);\n        //因为int3是不被序列化的，所以这里不能写此语句\n        EditorGUILayout.PropertyField(this.int4);\n        EditorGUILayout.PropertyField(this.valueTest, true);\n        //true属性意思是设置显示子节点，也就是显示TypeDemo里面的属性\n\n        this.mObj.ApplyModifiedProperties();\n        //应用属性修改\n    &#125;\n&#125;\n\n</code></pre>\n<p>效果如图</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231025232755437.png\" alt=\"image-20231025232755437\"></p>\n<p>可以看到自定义的 Editor 界面不受类本身的属性表示控制。</p>\n<h2><span id=\"3-自定义序列化属性字段\"> 3、自定义序列化属性字段</span></h2>\n<p>此时，我想要当前属性随着我的枚举值的变化而变化，即我选择一个枚举时，其他属性处于不被 editor 绘制的状态。</p>\n<p>方法：</p>\n<p>第一步，创建并书写对应类的脚本和编辑器脚本，这里分别命名为 EnumEditor 和 Enum。</p>\n<pre><code class=\"language-c#\">using System;\n\npublic class Enum : MonoBehaviour\n&#123;\n    public selectedEnum selectedEnum;\n    public GameObject 碰撞盒;\n    public GameObject 特效;\n    public AnimationClip 动作;\n&#125;\n\n[Serializable]\npublic enum selectedEnum\n&#123; \n碰撞盒,\n特效,\n动作,\n&#125;\n</code></pre>\n<p>仅有 Enum 时</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231025234839268.png\" alt=\"image-20231025234839268\"></p>\n<p>EnumEditor：</p>\n<pre><code class=\"language-c#\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\n[CustomEditor(typeof(Enum))]\npublic class EnumEditor : Editor\n&#123;\n    public SerializedObject mObj;\n    public SerializedProperty selectedEnum;\n    public SerializedProperty 碰撞盒;\n    public SerializedProperty 特效;\n    public SerializedProperty 动作;\n\n    private void OnEnable()\n    &#123;\n        //初始化\n        this.mObj = new SerializedObject(target);\n        this.selectedEnum = this.mObj.FindProperty(&quot;selectedEnum&quot;);\n        this.碰撞盒 = this.mObj.FindProperty(&quot;碰撞盒&quot;);\n        this.特效 = this.mObj.FindProperty(&quot;特效&quot;);\n        this.动作 = this.mObj.FindProperty(&quot;动作&quot;);\n    &#125;\n\n    public override void OnInspectorGUI()\n    &#123;\n        this.mObj.Update();\n        EditorGUILayout.PropertyField(this.selectedEnum);\n        //使用switch做条件筛选，this.mEnumDemo.enumValueIndex作为筛选条件，index从0开始，由于我设置枚举类型的第一个属性为None，所以case的值从1开始。\n        switch (this.selectedEnum.enumValueIndex)\n        &#123;\n            case 0:\n                EditorGUILayout.PropertyField(this.碰撞盒);\n                break;\n            case 1:\n                EditorGUILayout.PropertyField(this.特效);\n                break;\n            case 2:\n                EditorGUILayout.PropertyField(this.动作);\n                break;\n        &#125;\n\n        this.mObj.ApplyModifiedProperties();\n    &#125;\n&#125;\n\n</code></pre>\n<p>编写后</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231025235035035.png\" alt=\"image-20231025235035035\"></p>\n<h2><span id=\"4-自定义操作界面\"> 4、自定义操作界面</span></h2>\n<p>当我们需要自定义操作界面时：</p>\n<p>需要用到 EditorGUILayout 方法：<a href=\"https://docs.unity.cn/cn/2019.4/ScriptReference/EditorGUILayout.html\">EditorGUILayout - Unity 脚本 API</a></p>\n<p>以下是常用的。</p>\n<h3><span id=\"a-界面的启动和关闭\"> a、界面的启动和关闭</span></h3>\n<p>创建一个类，存放在 Assets–&gt;Editor 里面，并继承自 EditorWindow</p>\n<pre><code class=\"language-c#\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\npublic class WindowsEditor : EditorWindow\n&#123;\n    [MenuItem(&quot;Menu/EditorWindow&quot;)]\n    //声明窗口路径\n\n    public static void ShowWindow()\n    &#123;\n        //CreateInstance会允许创建多个窗口，推荐使用系统自带的单例模式getwindows\n        //使用官方提供的实例化窗口方法调用\n        WindowsEditor.CreateInstance&lt;WindowsEditor&gt;().Show();\n\n        //浮动型的窗口，跟点击Building Setting出现的窗口效果一样\n        WindowsEditor.CreateInstance&lt;WindowsEditor&gt;().ShowUtility();\n\n        //弹出窗口时的效果\n        WindowsEditor.CreateInstance&lt;WindowsEditor&gt;().ShowPopup();\n        //此方法和下面的OnGUI配合着使用，否则会出现页面关不掉的情况,此时不会出现UI自带的关闭界面\n\n        //使用系统提供的单例模式，在unity面板中打开窗口时，只会出现一个(推荐)\n        WindowsEditor.GetWindow&lt;WindowsEditor&gt;().Show();\n    &#125;\n\n    public void OnGUI()\n    &#123;\n        if (GUILayout.Button(&quot;关闭&quot;))\n        &#123;\n            this.Close();\n        &#125;\n    &#125;\n    \n&#125;\n\n</code></pre>\n<p>每个方法效果如下</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/images/Loading1.gif\" data-original=\"image-20231026000101143.png\" alt=\"image-20231026000101143\"></th>\n<th><img src=\"/images/Loading1.gif\" data-original=\"image-20231026000129453.png\" alt=\"image-20231026000129453\"></th>\n<th><img src=\"/images/Loading1.gif\" data-original=\"image-20231026000158455.png\" alt=\"image-20231026000158455\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Show</td>\n<td>ShowUtility</td>\n<td>ShowPopup</td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"b-界面的事件相关\"> b、界面的事件相关</span></h3>\n<p>自定义页面中有时会使用自定义的事件，事件通常如下：</p>\n<pre><code class=\"language-c#\">    public int index_1 = 0;\n    //刷新方法，每秒钟100次\n    public void Update()\n    &#123;\n        index_1++;\n        Debug.Log(&quot;index_1：&quot; + index_1);\n    &#125;\n\n    public int index_2 = 0;\n    //刷新方法，刷新周期比Update小\n    public void OnInspectorUpdate()\n    &#123;\n        index_2++;\n        Debug.Log(&quot;index_2：&quot; + index_2);\n    &#125;\n\n    //视图被删除的时候触发\n    public void OnDestroy()\n    &#123;\n        Debug.Log(&quot;OnDestroy：触发&quot;);\n    &#125;\n\n    //选择一个对象的时候触发\n    public void OnSelectionChange()\n    &#123;\n        //获取选择Hierarchy里面游戏物体的时候的名字\n        for (int i = 0; i &lt; Selection.gameObjects.Length; i++)\n        &#123;\n            Debug.Log(&quot;OnSelectionChange：触发&quot; + Selection.gameObjects[i].name);\n        &#125;\n\n        //获取选择Project里面的文件的名字\n        for (int i = 0; i &lt; Selection.objects.Length; i++)\n        &#123;\n            Debug.Log(&quot;OnSelectionChange：触发&quot; + Selection.objects[i].name);\n        &#125;\n    &#125;\n\n    //获得焦点的时候触发\n    public void OnFocus()\n    &#123;\n        Debug.Log(&quot;OnFocus：触发&quot;);\n    &#125;\n\n    //失去焦点的时候触发\n    public void OnLostFocus()\n    &#123;\n        Debug.Log(&quot;OnLostFocus：触发&quot;);\n    &#125;\n\n    //Hierarchy更改的时候触发\n    public void OnHierarchyChange()\n    &#123;\n        Debug.Log(&quot;OnHierarchyChange：触发&quot;);\n    &#125;\n\n    //Project更改的时候触发\n    public void OnProjectChange()\n    &#123;\n        Debug.Log(&quot;OnProjectChange：触发&quot;);\n    &#125;\n</code></pre>\n<h3><span id=\"c-文本-颜色字段\"> c、文本 / 颜色字段</span></h3>\n<pre><code class=\"language-c#\">\n    public string 文本 = &quot;默认文字&quot;;\n    public Color 颜色 = Color.white;\n    public void OnGUI()\n    &#123;\n        if (GUILayout.Button(&quot;关闭&quot;))\n        &#123;\n            this.Close();\n        &#125;\n        //一行文本，单行输入框\n        this.文本 = EditorGUILayout.TextField(this.文本);\n        //多行输入框\n        this.文本 = EditorGUILayout.TextArea(this.文本);\n        //密码输入框\n        this.文本 = EditorGUILayout.PasswordField(this.文本);\n        //颜色选择框\n        this.颜色 = EditorGUILayout.ColorField(this.颜色);\n    &#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026001735821.png\" alt=\"image-20231026001735821\"></p>\n<h3><span id=\"d-标签字段\"> d、标签字段</span></h3>\n<p>类似于 [header (“”)] 标识，在 gui 中显示 tag。</p>\n<pre><code class=\"language-c#\">    public string 文本 = &quot;默认文字&quot;;\n    public Color 颜色 = Color.white;\n\tpublic void OnGUI()\n    &#123;\n        //标签\n        EditorGUILayout.PrefixLabel(this.文本);//只写这么一行代码，窗口里面不出现任何内容\n        EditorGUILayout.Space();//换行\n\n        //标签（下拉框）\n        this.文本 = EditorGUILayout.TagField(this.文本);\n        EditorGUILayout.Space();\n\n        //标签（非可选择标签提示）\n        EditorGUILayout.LabelField(this.文本);\n        EditorGUILayout.Space();\n\n        //标签（可选择标签提示）\n        EditorGUILayout.SelectableLabel(this.文本);\n        EditorGUILayout.Space();\n    &#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026002300584.png\" alt=\"image-20231026002300584\"></p>\n<h3><span id=\"e-输入字段\"> e、输入字段</span></h3>\n<pre><code class=\"language-c#\">   public string 文本 = &quot;默认文字&quot;;\n    public int 数字;\n\n    public void OnGUI()\n    &#123;\n        EditorGUILayout.LabelField(&quot;输入整形数字&quot;);\n        this.数字 = EditorGUILayout.IntField(this.数字);\n        EditorGUILayout.LabelField(&quot;输入字符&quot;);\n        this.文本 = EditorGUILayout.TextField(this.文本);\n    &#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026002601592.png\" alt=\"image-20231026002601592\"></p>\n<h3><span id=\"f-滑动条\"> f、滑动条</span></h3>\n<pre><code class=\"language-c#\">    public int 数字;\n    public float 浮点数;\n    public float 浮点最大值;\n    public float 浮点最小值;\n    public void OnGUI()\n    &#123;\n        //滑动条  参数1：默认值，参数2：最小值，参数3：最大值\n        this.浮点数 = EditorGUILayout.Slider(this.浮点数, 0, 100);//取值区间有小数\n\n        this.数字 = EditorGUILayout.IntSlider(this.数字, 0, 100);//取值区间为整数\n\n        //最小值到最大值的取值范围，为0-100\n        EditorGUILayout.MinMaxSlider(ref 浮点最小值, ref 浮点最大值, 0, 100);\n    &#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026003117435.png\" alt=\"image-20231026003117435\"></p>\n<h3><span id=\"g-vector-输入字段\"> g、Vector 输入字段</span></h3>\n<pre><code class=\"language-c#\">    public Vector3 mPos3;\n    public void OnGUI()\n    &#123;\n        this.mPos3 = EditorGUILayout.Vector3Field(&quot;三维坐标&quot;, this.mPos3);\n        EditorGUILayout.Space();\n    &#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026003443557.png\" alt=\"image-20231026003443557\"></p>\n<h3><span id=\"h-选择\"> h、选择</span></h3>\n<pre><code class=\"language-c#\">public int index;\npublic void OnGUI()\n    &#123;        \n    \tstring[] strs = &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ,&quot;e&quot;&#125;;\n        int[] ints = &#123; 1, 2, 3, 4, 5 &#125;;\n        this.index = EditorGUILayout.Popup(this.index, strs);\n        this.index = EditorGUILayout.IntPopup(this.index, strs,ints);\n        EditorGUILayout.Space();\n    &#125;\n</code></pre>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026004155844.png\" alt=\"image-20231026004155844\"></p>\n<p>i、对象选择</p>\n<pre><code class=\"language-c#\">    public string mTag;\n    public int mLayer;\n    public Object mObject;\n    public void OnGUI()\n    &#123;\n        //标签，下面两种写法，哪个都可以\n        //this.mTag = EditorGUILayout.TagField(this.mTag);\n        this.mTag = EditorGUILayout.TagField(&quot;Tag&quot;);\n        EditorGUILayout.Space();\n        //层\n         this.mLayer = EditorGUILayout.LayerField(this.mLayer);\n         EditorGUILayout.Space();\n         //对象选择，如果想要存放所有的元素，那么参数就写为Object： typeof(Object)\n        this.mObject = EditorGUILayout.ObjectField(&quot;对象选择器&quot;, this.mObject, typeof(Camera), true);\n   &#125;\n</code></pre>\n<hr>\n<p>从其他博客中学到的，原作者：<a href=\"https://www.cnblogs.com/yzx885059439/p/14497026.html\">Unity3D 插件开发教程 - 挽风入我怀 - 博客园 (cnblogs.com)</a></p>\n",
            "tags": [
                "程序",
                "unity"
            ]
        }
    ]
}