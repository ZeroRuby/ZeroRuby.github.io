{
    "version": "https://jsonfeed.org/version/1",
    "title": "红玉のblog",
    "description": "",
    "home_page_url": "https://zeroruby.github.io",
    "items": [
        {
            "id": "https://zeroruby.github.io/2024/07/02/%E5%BC%80%E6%94%BE%E4%B8%96%E7%95%8C%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%85%B3%E5%8D%A1%E8%8A%82%E5%A5%8F%E9%97%AE%E9%A2%98/",
            "url": "https://zeroruby.github.io/2024/07/02/%E5%BC%80%E6%94%BE%E4%B8%96%E7%95%8C%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%85%B3%E5%8D%A1%E8%8A%82%E5%A5%8F%E9%97%AE%E9%A2%98/",
            "title": "开放世界类型中的关卡节奏问题",
            "date_published": "2024-07-02T01:14:12.000Z",
            "content_html": "<p>一篇关于分析关卡节奏是什么、怎么用，并通过对部分开放世界游戏进行案例分析进行论证的文章。</p>\n<span id=\"more\"></span>\n<hr>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E4%B8%80-%E5%89%8D%E8%A8%80\">一、前言</a>\n<ul>\n<li><a href=\"#1-%E5%85%B3%E5%8D%A1%E8%8A%82%E5%A5%8F%E6%98%AF%E4%BB%80%E4%B9%88\">1、关卡节奏是什么</a></li>\n<li><a href=\"#2-%E8%8A%82%E5%A5%8F%E4%B8%8E%E7%8E%A9%E5%AE%B6%E6%BF%80%E5%8A%B1\">2、节奏与玩家激励</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%8C-%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E8%8A%82%E5%A5%8F\">二、如何衡量节奏</a>\n<ul>\n<li><a href=\"#1-%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8D%95%E5%85%83\">1、流程中的最小单元</a></li>\n<li><a href=\"#2-%E8%A1%A1%E9%87%8F%E8%8A%82%E5%A5%8F\">2、衡量节奏</a></li>\n<li><a href=\"#3-%E5%9F%BA%E4%BA%8E%E9%A1%B9%E7%9B%AE%E8%A1%A1%E9%87%8F%E8%8A%82%E5%A5%8F\">3、基于项目衡量节奏</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%89-%E5%85%B3%E5%8D%A1%E8%8A%82%E5%A5%8F%E5%88%86%E6%9E%90\">三、关卡节奏分析</a>\n<ul>\n<li><a href=\"#1-%E6%B8%B8%E6%88%8F%E7%B1%BB%E5%9E%8B%E5%88%86%E6%9E%90\">1、游戏类型分析</a></li>\n<li><a href=\"#2-%E8%9C%98%E8%9B%9B%E4%BE%A02%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90\">2、《蜘蛛侠 2》流程分析</a>\n<ul>\n<li><a href=\"#1%E5%85%B3%E5%8D%A1%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90\">（1）关卡组件分析</a></li>\n<li><a href=\"#2%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90\">（2）流程分析</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<hr>\n<h1><span id=\"一-前言\"> 一、前言</span></h1>\n<h2><span id=\"1-关卡节奏是什么\"> 1、关卡节奏是什么</span></h2>\n<p>在 2014 年的 GDC 上，曾经有一位来自 V 社的游戏设计师对这方面的内容进行过分享。</p>\n<p>总体上来看，节奏描述的是活动、活动强度和活动持续时间的关系。</p>\n<p>在游戏设计上，可以定性的说，节奏是一种用来维持玩家对游戏兴趣的一种工具，可以想玩家传达情感，也能帮助控制事件对玩家的影响。</p>\n<h2><span id=\"2-节奏与玩家激励\"> 2、节奏与玩家激励</span></h2>\n<p>为了吸引玩家持续且沉浸的进行游戏，需要通过一些奖励或事件来推动玩家继续前进，如：物品、故事要素、战斗、宝箱等等。</p>\n<h1><span id=\"二-如何衡量节奏\"> 二、如何衡量节奏</span></h1>\n<p>通常为了更好的优化游戏体验，正确的确定游戏流程中的节奏能为游戏设计带来更多的便利。</p>\n<p>通常我们希望能以图表的形式对节奏进行可视化的测量，其横轴可以使用时间、事件等作为单位，然而其纵轴作为强度（intensity）却是一个十分抽象的概念。</p>\n<p>那么如何衡量节奏的强度呢？</p>\n<h2><span id=\"1-流程中的最小单元\"> 1、流程中的最小单元</span></h2>\n<p>首先我们需要寻找节奏的最小单元，我们需要引入传统电影中的叙事结构的分析中最小的单元：“节拍”，分析如下：</p>\n<p>在传统动画和影视行业中，以一部电影为例，电影中的剧情会有一些关键的事件推动剧情的发展，称之为<em><strong>激励事件</strong></em>，这些事件是在通过 “幕” 来进行分割的，以常规电影的 “三幕式” 结构进行划分，不同的事件安插在不同的幕间（例如：中点事件在第二幕，作为进展纠纷、提升节奏的重要事件，通常一部电影的优劣也可以通过后续事件的情绪高潮是否高过中点事件来判断电影的结构完整性）。这些事件正是由一个个的 “节拍” 组成。在传统电影叙事中，一个节拍是动作 \\ 反应中的一种行为交流，而在游戏设计上，<em><strong>节拍认为是玩家交互的一次行为</strong></em>。</p>\n<p>一个个节拍构成了一个场景，诸多场景组成一个流程。如果一个流程中节拍出现的太过频繁，玩家会应接不暇，反之也会感到无聊。</p>\n<h2><span id=\"2-衡量节奏\"> 2、衡量节奏</span></h2>\n<p>在找到流程设计中的最小单元之后，我们的节奏量表的纵轴就可以确定了，那就是我们的节拍数（通过上述论述可以确定，一个节拍认为是一次交互）。</p>\n<p>通过对不同游戏中的玩法、战斗、探索、奖励拆分成量化的节拍数，即可对关卡的节奏强度进行衡量。</p>\n<p>举个例子：衡量战斗的节拍数就是寻找战斗的最小周期，如射击游戏中，最小周期是一次弹夹的更换。在 ARPG 中，可以是一次连段、一次闪避等等（即进行交互后回到初始状态视为一次周期）。那么在流程中存在需要多少个节拍才能解决的战斗，就认为这个流程的战斗强度为多少。</p>\n<p>可以发现这是一种较为通用的衡量节奏的方法。</p>\n<h2><span id=\"3-基于项目衡量节奏\"> 3、基于项目衡量节奏</span></h2>\n<p>通过上述方式我们找到了一个能较为通用的衡量关卡节奏的方法，但未免有些复杂，在实际的项目开发中，需要有一个通用的讨论节奏的方法，使其不需要繁琐的换算来衡量节奏。</p>\n<p>例如在 V 社游戏半条命 2 中，开发团队有一种针对项目的来讨论节奏的方法，通过运用这种方法能将整个游戏概括成几个基本的组成部分：战斗、谜题、探索、编排和街景。在完成拆分后对每个组成部分进行下定义。</p>\n<ul>\n<li>战斗（Combat）：描述一个玩家参与到一场战斗当中的任何时间</li>\n<li>探索（Explore）：用于说明玩家走遍游戏环境、而不主动参与谜题解决和战斗的部分</li>\n<li>谜题（Puzzle）：玩家必须克服的挑战。在解决之前无法前进</li>\n<li>编排（choreography）：动画场景，如：镜头调度、动画演出等部分。</li>\n<li>街景：吸引玩家视觉兴趣的区域</li>\n</ul>\n<p>因此基于上述的分析，在 14 年的 GDC 上，开发者对《半条命 2》中第二章的关卡进行了分析</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"/image-20240702103328593-17198876114711.png\" alt=\"image-20240702103328593\"></p>\n<p>开发者对这张图进行边缘化，即可得到关卡的节奏曲线：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"/image-20240702103408621-17198876505782.png\" alt=\"image-20240702103408621\"></p>\n<p>再对关卡进行分析，添加事件之间的过渡，得到如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"/image-20240702103441001.png\" alt=\"image-20240702103441001\"></p>\n<p>因此，在实际项目开发中，对于一些较为通用和常规的关卡，我们可以使用这种方法快速确定关卡的节奏曲线。</p>\n<h1><span id=\"三-关卡节奏分析\"> 三、关卡节奏分析</span></h1>\n<p>在完成上述的关卡节奏的探索后，我们来探索开放世界游戏中的一些关于关卡节奏方面的问题。</p>\n<h2><span id=\"1-游戏类型分析\"> 1、游戏类型分析</span></h2>\n<p>开放世界游戏不同的项目设计方式也大相径庭。因此从关卡体验和流程的角度上，我们拆分成一下几类。</p>\n<ul>\n<li>以 POI 为主要引导的：如老头环、野炊和王泪等属于这一类，这一类开放世界游戏极大程度的削弱的引导，所以在关卡节奏的衡量上也相对更加困难。</li>\n<li>以任务、战斗为引导的：如原神、蜘蛛侠 2 等属于这一类，这一类开放世界在流程设计上仍然类似于传统箱庭关卡，在节奏的衡量方面相对更加容易</li>\n</ul>\n<h2><span id=\"2-蜘蛛侠-2流程分析\"> 2、《蜘蛛侠 2》流程分析</span></h2>\n<h3><span id=\"1关卡组件分析\"> （1）关卡组件分析</span></h3>\n<p>分析关卡之前需要确定该游戏中的流程有哪些组件</p>\n<ul>\n<li>\n<p>CG 动画：CG 动画的节奏和叙事有关，通常不在流程中</p>\n</li>\n<li>\n<p>战斗：蜘蛛侠的战斗包含了格斗、跑酷的内容。一个基础小怪可以用一套连招击杀，视为一个周期，那么可以认为含有一个小怪的战斗其节奏为 1，精英怪为 3，一个战斗场景的节奏为玩家同时面对的敌人的数量（OB 的怪物不算在内）</p>\n</li>\n<li>\n<p>过场动画：用于衔接幕间的时长较短的动画，通常为实际动画，视为单个单元，节奏放缓，为 1</p>\n</li>\n<li>\n<p>解密：在关卡流程中完成特定玩法进入下一个流程，根据谜题难度而定，简单谜题定为 2</p>\n</li>\n<li>\n<p>探索：即不战斗也不解密的过程。由于蜘蛛侠系列存在跑酷玩法，故探索过程中的节奏相对其他类型的游戏较高，其单位时间内完成的周期性动作是固定的，可以视为探索过程中，节奏为 3</p>\n<p>(除战斗以外的其他部分的节奏衡量无需过于精准，因为确定了波峰和波谷之后，其他的误差不会对结果有太大影响。一些特殊的战斗，如追逐战需要特别对待)</p>\n</li>\n</ul>\n<h3><span id=\"2流程分析\"> （2）流程分析</span></h3>\n<p>对游戏的新手关卡进行分析</p>\n<hr>\n<p>过几天更新</p>\n",
            "tags": [
                "关卡"
            ]
        },
        {
            "id": "https://zeroruby.github.io/2023/10/25/Unity%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "https://zeroruby.github.io/2023/10/25/Unity%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "Unity插件制作学习笔记",
            "date_published": "2023-10-24T16:00:00.000Z",
            "content_html": "<p>记录自己学习 unity 制作插件时的细节和 tips，有任何问题或疑惑请随时通过主页联系方式联系我一起探讨。</p>\n<span id=\"more\"></span>\n<hr>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E4%B8%80-%E8%87%AA%E5%AE%9A%E4%B9%89inspector%E7%95%8C%E9%9D%A2\">一、自定义 Inspector 界面</a>\n<ul>\n<li><a href=\"#1-%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3%E6%A0%87%E8%AF%86\">1、属性相关标识</a></li>\n<li><a href=\"#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%95%8C%E9%9D%A2%E5%B1%9E%E6%80%A7\">2、自定义界面属性</a></li>\n<li><a href=\"#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E5%B1%9E%E6%80%A7%E5%AD%97%E6%AE%B5\">3、自定义序列化属性字段</a></li>\n<li><a href=\"#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C%E7%95%8C%E9%9D%A2\">4、自定义操作界面</a>\n<ul>\n<li><a href=\"#a-%E7%95%8C%E9%9D%A2%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD\">a、界面的启动和关闭</a></li>\n<li><a href=\"#b-%E7%95%8C%E9%9D%A2%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3\">b、界面的事件相关</a></li>\n<li><a href=\"#c-%E6%96%87%E6%9C%AC%E9%A2%9C%E8%89%B2%E5%AD%97%E6%AE%B5\">c、文本 / 颜色字段</a></li>\n<li><a href=\"#d-%E6%A0%87%E7%AD%BE%E5%AD%97%E6%AE%B5\">d、标签字段</a></li>\n<li><a href=\"#e-%E8%BE%93%E5%85%A5%E5%AD%97%E6%AE%B5\">e、输入字段</a></li>\n<li><a href=\"#f-%E6%BB%91%E5%8A%A8%E6%9D%A1\">f、滑动条</a></li>\n<li><a href=\"#g-vector%E8%BE%93%E5%85%A5%E5%AD%97%E6%AE%B5\">g、Vector 输入字段</a></li>\n<li><a href=\"#h-%E9%80%89%E6%8B%A9\">h、选择</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<hr>\n<h1><span id=\"一-自定义-inspector-界面\"> 一、自定义 Inspector 界面</span></h1>\n<h2><span id=\"1-属性相关标识\"> 1、属性相关标识</span></h2>\n<p>5 种变量在 inspector 隐藏和显示的方法</p>\n<pre><code class=\"language-c#\">using System;\n\npublic class Value : MonoBehaviour\n&#123;\n    \n    public int int1;  \n\n    [HideInInspector]//直接隐藏在inspector  \n    public int int2=3;  \n\n    [NonSerialized]//隐藏的同时不会保存被inspector序列化后的值   \n    public int int3=3;//即更改inspector的值不会影响脚本的初始赋值  \n\n    [SerializeField]//将私有变量显示在inspector  \n    private int int4;  \n\n    public ValueTest valueTest = new ValueTest();  \n\n&#125;\n\n[Serializable]//可让自定义的类显示在inspector  \npublic class ValueTest   \n&#123;\n    public int int5;  \n&#125;\n</code></pre>\n<p>最终在 inspector 的表现效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231025225218480.png\" alt=\"image-20231025225218480\"></p>\n<p>这里涉及到 unity 中 inspector 的数据持久化问题，即序列化，参考文档：<a href=\"https://docs.unity.cn/cn/2020.3/Manual/script-Serialization.html\">脚本序列化 - Unity 手册</a></p>\n<p>“序列化是将数据结构或对象状态转换为 Unity 可存储并在以后可重构的格式的自动过程。”</p>\n<p>如果在自定义 inspector 的脚本中，没有使用派生子 editor 基类的方法 FindProperty () 来获取 target 中的变量时，是无法被序列化保存的，需要注意。</p>\n<h2><span id=\"2-自定义界面属性\"> 2、自定义界面属性</span></h2>\n<p>创建自定义界面需要在 Asset 路径下创建名为 Editor 的文件夹，此命名的文件夹打包时不会被打包（Resources 文件夹同理，在 load 方法加载资源时要注意路径<a href=\"https://docs.unity.cn/cn/2019.3/ScriptReference/Resources.Load.html\">（Resources-Load - Unity 脚本 API）</a>）</p>\n<p>创建上述 Value 的自定义 inspector：</p>\n<p>第一步：创建继承 Editor 基类的脚本，并将其放在 Editor 文件夹下，并声明是 Value 的界面</p>\n<pre><code class=\"language-c#\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\n[CustomEditor(typeof(Value))]\npublic class ValueEditor :Editor\n&#123;\n  \n    public SerializedObject mObj;   //定义序列化目标对象\n    //序列化出来几个属性\n    //属性对应的是[CustomEditor(typeof(Value))]中，Value类里面的属性\n\n    public SerializedProperty int1;\n    public SerializedProperty int2;\n    public SerializedProperty int3;\n    public SerializedProperty int4;\n    public SerializedProperty valueTest;\n\n    //选择当前游戏对象\n    private void OnEnable()\n    &#123;\n        //初始化\n        this.mObj = new SerializedObject(target);\n        //通过字符串名字，查找Test1类里面的属性，并进行初始化\n        this.int1 = this.mObj.FindProperty(&quot;int1&quot;);\n        this.int2 = this.mObj.FindProperty(&quot;int2&quot;);\n        this.int3 = this.mObj.FindProperty(&quot;int3&quot;);\n        this.int4 = this.mObj.FindProperty(&quot;int4&quot;);\n        this.valueTest = this.mObj.FindProperty(&quot;valueTest&quot;);\n    &#125;\n\n    //绘制\n    public override void OnInspectorGUI()\n    &#123;\n        this.mObj.Update();\n\n        EditorGUILayout.PropertyField(this.int1);\n        EditorGUILayout.PropertyField(this.int2);\n        //EditorGUILayout.PropertyField(this.int3);\n        //因为int3是不被序列化的，所以这里不能写此语句\n        EditorGUILayout.PropertyField(this.int4);\n        EditorGUILayout.PropertyField(this.valueTest, true);\n        //true属性意思是设置显示子节点，也就是显示TypeDemo里面的属性\n\n        this.mObj.ApplyModifiedProperties();\n        //应用属性修改\n    &#125;\n&#125;\n\n</code></pre>\n<p>效果如图</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231025232755437.png\" alt=\"image-20231025232755437\"></p>\n<p>可以看到自定义的 Editor 界面不受类本身的属性标识控制。</p>\n<h2><span id=\"3-自定义序列化属性字段\"> 3、自定义序列化属性字段</span></h2>\n<p>此时，我想要当前属性随着我的枚举值的变化而变化，即我选择一个枚举时，其他属性处于不被 editor 绘制的状态。</p>\n<p>方法：</p>\n<p>第一步，创建并书写对应类的脚本和编辑器脚本，这里分别命名为 EnumEditor 和 Enum。</p>\n<pre><code class=\"language-c#\">using System;\n\npublic class Enum : MonoBehaviour\n&#123;\n    public selectedEnum selectedEnum;\n    public GameObject 碰撞盒;\n    public GameObject 特效;\n    public AnimationClip 动作;\n&#125;\n\n[Serializable]\npublic enum selectedEnum\n&#123; \n碰撞盒,\n特效,\n动作,\n&#125;\n</code></pre>\n<p>仅有 Enum 时</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231025234839268.png\" alt=\"image-20231025234839268\"></p>\n<p>EnumEditor：</p>\n<pre><code class=\"language-c#\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\n[CustomEditor(typeof(Enum))]\npublic class EnumEditor : Editor\n&#123;\n    public SerializedObject mObj;\n    public SerializedProperty selectedEnum;\n    public SerializedProperty 碰撞盒;\n    public SerializedProperty 特效;\n    public SerializedProperty 动作;\n\n    private void OnEnable()\n    &#123;\n        //初始化\n        this.mObj = new SerializedObject(target);\n        this.selectedEnum = this.mObj.FindProperty(&quot;selectedEnum&quot;);\n        this.碰撞盒 = this.mObj.FindProperty(&quot;碰撞盒&quot;);\n        this.特效 = this.mObj.FindProperty(&quot;特效&quot;);\n        this.动作 = this.mObj.FindProperty(&quot;动作&quot;);\n    &#125;\n\n    public override void OnInspectorGUI()\n    &#123;\n        this.mObj.Update();\n        EditorGUILayout.PropertyField(this.selectedEnum);\n        switch (this.selectedEnum.enumValueIndex)\n        &#123;\n            case 0:\n                EditorGUILayout.PropertyField(this.碰撞盒);\n                break;\n            case 1:\n                EditorGUILayout.PropertyField(this.特效);\n                break;\n            case 2:\n                EditorGUILayout.PropertyField(this.动作);\n                break;\n        &#125;\n\n        this.mObj.ApplyModifiedProperties();\n    &#125;\n&#125;\n\n</code></pre>\n<p>编写后</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231025235035035.png\" alt=\"image-20231025235035035\"></p>\n<h2><span id=\"4-自定义操作界面\"> 4、自定义操作界面</span></h2>\n<p>当我们需要自定义操作界面时：</p>\n<p>需要用到 EditorGUILayout 方法：<a href=\"https://docs.unity.cn/cn/2019.4/ScriptReference/EditorGUILayout.html\">EditorGUILayout - Unity 脚本 API</a></p>\n<p>以下是常用的。</p>\n<h3><span id=\"a-界面的启动和关闭\"> a、界面的启动和关闭</span></h3>\n<p>创建一个类，存放在 Assets–&gt;Editor 里面，并继承自 EditorWindow</p>\n<pre><code class=\"language-c#\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\npublic class WindowsEditor : EditorWindow\n&#123;\n    [MenuItem(&quot;Menu/EditorWindow&quot;)]\n    //声明窗口路径\n\n    public static void ShowWindow()\n    &#123;\n        //CreateInstance会允许创建多个窗口，推荐使用系统自带的单例模式getwindows\n        //使用官方提供的实例化窗口方法调用\n        WindowsEditor.CreateInstance&lt;WindowsEditor&gt;().Show();\n\n        //浮动型的窗口，跟点击Building Setting出现的窗口效果一样\n        WindowsEditor.CreateInstance&lt;WindowsEditor&gt;().ShowUtility();\n\n        //弹出窗口时的效果\n        WindowsEditor.CreateInstance&lt;WindowsEditor&gt;().ShowPopup();\n        //此方法和下面的OnGUI配合着使用，否则会出现页面关不掉的情况,此时不会出现UI自带的关闭界面\n\n        //使用系统提供的单例模式，在unity面板中打开窗口时，只会出现一个(推荐)\n        WindowsEditor.GetWindow&lt;WindowsEditor&gt;().Show();\n    &#125;\n\n    public void OnGUI()\n    &#123;\n        if (GUILayout.Button(&quot;关闭&quot;))\n        &#123;\n            this.Close();\n        &#125;\n    &#125;\n    \n&#125;\n\n</code></pre>\n<p>每个方法效果如下</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/images/Loading1.gif\" data-original=\"image-20231026000101143.png\" alt=\"image-20231026000101143\"></th>\n<th><img src=\"/images/Loading1.gif\" data-original=\"image-20231026000129453.png\" alt=\"image-20231026000129453\"></th>\n<th><img src=\"/images/Loading1.gif\" data-original=\"image-20231026000158455.png\" alt=\"image-20231026000158455\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Show</td>\n<td>ShowUtility</td>\n<td>ShowPopup</td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"b-界面的事件相关\"> b、界面的事件相关</span></h3>\n<p>自定义页面中有时会使用自定义的事件，事件通常如下：</p>\n<pre><code class=\"language-c#\">    public int index_1 = 0;\n    //刷新方法，每秒钟100次\n    public void Update()\n    &#123;\n        index_1++;\n        Debug.Log(&quot;index_1：&quot; + index_1);\n    &#125;\n\n    public int index_2 = 0;\n    //刷新方法，刷新周期比Update小\n    public void OnInspectorUpdate()\n    &#123;\n        index_2++;\n        Debug.Log(&quot;index_2：&quot; + index_2);\n    &#125;\n\n    //视图被删除的时候触发\n    public void OnDestroy()\n    &#123;\n        Debug.Log(&quot;OnDestroy：触发&quot;);\n    &#125;\n\n    //选择一个对象的时候触发\n    public void OnSelectionChange()\n    &#123;\n        //获取选择Hierarchy里面游戏物体的时候的名字\n        for (int i = 0; i &lt; Selection.gameObjects.Length; i++)\n        &#123;\n            Debug.Log(&quot;OnSelectionChange：触发&quot; + Selection.gameObjects[i].name);\n        &#125;\n\n        //获取选择Project里面的文件的名字\n        for (int i = 0; i &lt; Selection.objects.Length; i++)\n        &#123;\n            Debug.Log(&quot;OnSelectionChange：触发&quot; + Selection.objects[i].name);\n        &#125;\n    &#125;\n\n    //获得焦点的时候触发\n    public void OnFocus()\n    &#123;\n        Debug.Log(&quot;OnFocus：触发&quot;);\n    &#125;\n\n    //失去焦点的时候触发\n    public void OnLostFocus()\n    &#123;\n        Debug.Log(&quot;OnLostFocus：触发&quot;);\n    &#125;\n\n    //Hierarchy更改的时候触发\n    public void OnHierarchyChange()\n    &#123;\n        Debug.Log(&quot;OnHierarchyChange：触发&quot;);\n    &#125;\n\n    //Project更改的时候触发\n    public void OnProjectChange()\n    &#123;\n        Debug.Log(&quot;OnProjectChange：触发&quot;);\n    &#125;\n</code></pre>\n<h3><span id=\"c-文本-颜色字段\"> c、文本 / 颜色字段</span></h3>\n<pre><code class=\"language-c#\">\n    public string 文本 = &quot;默认文字&quot;;\n    public Color 颜色 = Color.white;\n    public void OnGUI()\n    &#123;\n        if (GUILayout.Button(&quot;关闭&quot;))\n        &#123;\n            this.Close();\n        &#125;\n        //一行文本，单行输入框\n        this.文本 = EditorGUILayout.TextField(this.文本);\n        //多行输入框\n        this.文本 = EditorGUILayout.TextArea(this.文本);\n        //密码输入框\n        this.文本 = EditorGUILayout.PasswordField(this.文本);\n        //颜色选择框\n        this.颜色 = EditorGUILayout.ColorField(this.颜色);\n    &#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026001735821.png\" alt=\"image-20231026001735821\"></p>\n<h3><span id=\"d-标签字段\"> d、标签字段</span></h3>\n<p>类似于 [header (“”)] 标识，在 gui 中显示 tag。</p>\n<pre><code class=\"language-c#\">    public string 文本 = &quot;默认文字&quot;;\n    public Color 颜色 = Color.white;\n\tpublic void OnGUI()\n    &#123;\n        //标签\n        EditorGUILayout.PrefixLabel(this.文本);//只写这么一行代码，窗口里面不出现任何内容\n        EditorGUILayout.Space();//换行\n\n        //标签（下拉框）\n        this.文本 = EditorGUILayout.TagField(this.文本);\n        EditorGUILayout.Space();\n\n        //标签（非可选择标签提示）\n        EditorGUILayout.LabelField(this.文本);\n        EditorGUILayout.Space();\n\n        //标签（可选择标签提示）\n        EditorGUILayout.SelectableLabel(this.文本);\n        EditorGUILayout.Space();\n    &#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026002300584.png\" alt=\"image-20231026002300584\"></p>\n<h3><span id=\"e-输入字段\"> e、输入字段</span></h3>\n<pre><code class=\"language-c#\">   public string 文本 = &quot;默认文字&quot;;\n    public int 数字;\n\n    public void OnGUI()\n    &#123;\n        EditorGUILayout.LabelField(&quot;输入整形数字&quot;);\n        this.数字 = EditorGUILayout.IntField(this.数字);\n        EditorGUILayout.LabelField(&quot;输入字符&quot;);\n        this.文本 = EditorGUILayout.TextField(this.文本);\n    &#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026002601592.png\" alt=\"image-20231026002601592\"></p>\n<h3><span id=\"f-滑动条\"> f、滑动条</span></h3>\n<pre><code class=\"language-c#\">    public int 数字;\n    public float 浮点数;\n    public float 浮点最大值;\n    public float 浮点最小值;\n    public void OnGUI()\n    &#123;\n        //滑动条  参数1：默认值，参数2：最小值，参数3：最大值\n        this.浮点数 = EditorGUILayout.Slider(this.浮点数, 0, 100);//取值区间有小数\n\n        this.数字 = EditorGUILayout.IntSlider(this.数字, 0, 100);//取值区间为整数\n\n        //最小值到最大值的取值范围，为0-100\n        EditorGUILayout.MinMaxSlider(ref 浮点最小值, ref 浮点最大值, 0, 100);\n    &#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026003117435.png\" alt=\"image-20231026003117435\"></p>\n<h3><span id=\"g-vector-输入字段\"> g、Vector 输入字段</span></h3>\n<pre><code class=\"language-c#\">    public Vector3 mPos3;\n    public void OnGUI()\n    &#123;\n        this.mPos3 = EditorGUILayout.Vector3Field(&quot;三维坐标&quot;, this.mPos3);\n        EditorGUILayout.Space();\n    &#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026003443557.png\" alt=\"image-20231026003443557\"></p>\n<h3><span id=\"h-选择\"> h、选择</span></h3>\n<pre><code class=\"language-c#\">public int index;\npublic void OnGUI()\n    &#123;        \n    \tstring[] strs = &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ,&quot;e&quot;&#125;;\n        int[] ints = &#123; 1, 2, 3, 4, 5 &#125;;\n        this.index = EditorGUILayout.Popup(this.index, strs);\n        this.index = EditorGUILayout.IntPopup(this.index, strs,ints);\n        EditorGUILayout.Space();\n    &#125;\n</code></pre>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231026004155844.png\" alt=\"image-20231026004155844\"></p>\n<p>i、对象选择</p>\n<pre><code class=\"language-c#\">    public string mTag;\n    public int mLayer;\n    public Object mObject;\n    public void OnGUI()\n    &#123;\n        //标签，下面两种写法，哪个都可以\n        //this.mTag = EditorGUILayout.TagField(this.mTag);\n        this.mTag = EditorGUILayout.TagField(&quot;Tag&quot;);\n        EditorGUILayout.Space();\n        //层\n         this.mLayer = EditorGUILayout.LayerField(this.mLayer);\n         EditorGUILayout.Space();\n         //对象选择，如果想要存放所有的元素，那么参数就写为Object： typeof(Object)\n        this.mObject = EditorGUILayout.ObjectField(&quot;对象选择器&quot;, this.mObject, typeof(Camera), true);\n   &#125;\n</code></pre>\n<hr>\n<p>参考文章：</p>\n<p><a href=\"https://www.cnblogs.com/yzx885059439/p/14497026.html\">Unity3D 插件开发教程 - 挽风入我怀 - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://www.cnblogs.com/fancybit/p/InspectorPersistantProblem.html\">Unity 自定义 Inspector 面板时的数据持久化问题 - FancyBit - 博客园 (cnblogs.com)</a></p>\n",
            "tags": [
                "程序",
                "unity"
            ]
        },
        {
            "id": "https://zeroruby.github.io/2023/10/19/%E6%89%93%E5%87%BB%E6%84%9F%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1/",
            "url": "https://zeroruby.github.io/2023/10/19/%E6%89%93%E5%87%BB%E6%84%9F%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1/",
            "title": "打击感和战斗手感优化设计",
            "date_published": "2023-10-18T16:00:00.000Z",
            "content_html": "<p>一篇关于如何进行打击感和战斗手感优化的文章</p>\n<span id=\"more\"></span>\n<hr>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E4%B8%80-%E5%89%8D%E8%A8%80\">一、前言</a>\n<ul>\n<li><a href=\"#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%98%E5%8C%96%E6%89%93%E5%87%BB%E6%84%9F\">1、为什么要优化打击感</a></li>\n<li><a href=\"#2-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E7%A7%80%E7%9A%84%E6%88%98%E6%96%97%E6%89%8B%E6%84%9F\">2、什么是优秀的战斗手感</a></li>\n<li><a href=\"#3-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E7%A7%80%E7%9A%84%E6%88%98%E6%96%97%E6%89%8B%E6%84%9F\">3、什么是优秀的战斗手感</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%8C-%E6%89%93%E5%87%BB%E6%84%9F%E5%92%8C%E6%89%8B%E6%84%9F%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0\">二、打击感和手感的影响因素</a></li>\n<li><a href=\"#%E4%B8%89-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%89%93%E5%87%BB%E6%84%9F\">三、如何优化打击感</a>\n<ul>\n<li><a href=\"#1-%E8%A7%86%E8%A7%89%E5%9B%A0%E7%B4%A0\">1、视觉因素</a>\n<ul>\n<li><a href=\"#1%E5%8A%A8%E4%BD%9C\">（1）动作</a></li>\n<li><a href=\"#2%E4%BD%8D%E7%A7%BB\">（2）位移</a></li>\n<li><a href=\"#3%E7%89%B9%E6%95%88\">（3）特效</a></li>\n<li><a href=\"#4ui%E5%92%8C%E5%90%8E%E5%A4%84%E7%90%86\">（4）UI 和后处理</a></li>\n</ul>\n</li>\n<li><a href=\"#2-%E5%90%AC%E8%A7%89%E5%9B%A0%E7%B4%A0\">2、听觉因素</a>\n<ul>\n<li><a href=\"#1%E9%9F%B3%E6%95%88\">（1）音效</a></li>\n</ul>\n</li>\n<li><a href=\"#3-%E8%BE%93%E5%85%A5%E5%9B%A0%E7%B4%A0\">3、输入因素</a>\n<ul>\n<li><a href=\"#1%E5%88%A4%E5%AE%9A\">（1）判定</a></li>\n<li><a href=\"#dic-id%E5%8A%A8%E4%BD%9C%E5%8F%96%E6%B6%882%E5%8A%A8%E4%BD%9C%E5%8F%96%E6%B6%88div\"><dic id=\"动作取消\">（2）动作取消</dic></a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E8%A7%A6%E8%A7%89%E5%9B%A0%E7%B4%A0\">4、触觉因素</a>\n<ul>\n<li><a href=\"#1%E6%8E%A7%E5%88%B6%E5%99%A8%E9%9C%87%E5%8A%A8\">（1）控制器震动</a></li>\n<li><a href=\"#2%E5%8A%9B%E5%8F%8D%E9%A6%88%E6%89%B3%E6%9C%BA\">（2）力反馈扳机</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<hr>\n<h1><span id=\"一-前言\"> 一、前言</span></h1>\n<h2><span id=\"1-为什么要优化打击感\"> 1、为什么要优化打击感</span></h2>\n<p>打击感对于任何一个拥有动作元素的游戏来说都是不可或缺的。通常来说，打击感优化会是动作游戏中一个较为核心的模块，也是一个难以做好的模块。</p>\n<p>但是打击感的提升对于游戏品质、玩家体感方面的提升都是巨大的，所以对于一款以战斗为核心的游戏而言，打击感的优化是比较重要的。</p>\n<p>另外，此处需要感谢<a href=\"https://space.bilibili.com/27429148?spm_id_from=333.999.0.0\">哲哥</a>的内容分享</p>\n<h2><span id=\"2-什么是优秀的战斗手感\"> 2、什么是优秀的战斗手感</span></h2>\n<p>战斗手感和打击感需要围绕三个重要因素进行设计</p>\n<ul>\n<li><strong>顺</strong>：优秀的动作操作体验应当非常顺滑，按下按钮立刻有所对应反应，做到所控即所得。</li>\n<li><strong>准</strong>：只有当命中反馈尽量精准时，才能让玩家信任游戏的操控体验，做到人机交互的统一。</li>\n<li><strong>爽</strong>：战斗节奏需要从压抑到释放的节奏变化，通过动作与各类视效、镜头和的联动达到对感官的本能冲击。</li>\n</ul>\n<h2><span id=\"3-什么是优秀的战斗手感\"> 3、什么是优秀的战斗手感</span></h2>\n<ul>\n<li>干脆利落</li>\n<li>攻击意图明确</li>\n<li>攻守双方协调统一</li>\n<li>动特音一体化</li>\n</ul>\n<h1><span id=\"二-打击感和手感的影响因素\"> 二、打击感和手感的影响因素</span></h1>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0.png\" alt=\"影响因素\"></p>\n<p>通过人的感知对打击感区分了四个方向的影响因素</p>\n<ul>\n<li>视觉：\n<ul>\n<li>动作</li>\n<li>位移</li>\n<li>特效</li>\n<li>UI</li>\n<li>后处理</li>\n</ul>\n</li>\n<li>听觉\n<ul>\n<li>音效</li>\n<li>背景音乐</li>\n</ul>\n</li>\n<li>输入\n<ul>\n<li>动作取消</li>\n<li>受击判定</li>\n<li>指令输入</li>\n</ul>\n</li>\n<li>触觉\n<ul>\n<li>控制器震动</li>\n</ul>\n</li>\n</ul>\n<h1><span id=\"三-如何优化打击感\"> 三、如何优化打击感</span></h1>\n<h2><span id=\"1-视觉因素\"> 1、视觉因素</span></h2>\n<h3><span id=\"1动作\"> （1）动作</span></h3>\n<ul>\n<li>\n<h4><span id=\"攻击动作\"> 攻击动作</span></h4>\n<ul>\n<li>\n<p>符合发力原理</p>\n<p>对于任何一个动作设计而言，其基本都需要符合发力原理。</p>\n<p>以人形骨骼为例，通常以腿→腰胯→肩手头的发力顺序来保证动作看起来顺畅。</p>\n<p>参考武打港片中（如：叶问系列）的打戏镜头，可以看出发力要符合人体结构才能看起来真实</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E5%8F%B6%E9%97%AE%E5%86%B2%E6%8B%B3.gif\" alt=\"叶问冲拳\" title=\"叶问 日字冲拳\"></p>\n</li>\n<li>\n<p>符合攻击意图</p>\n<ul>\n<li>蓄力→释放</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E6%99%AE%E9%80%9A%E5%8A%A8%E4%BD%9C.gif\" alt=\"普通动作\"></p>\n<p>​\t\t\t\t\t这是一个没有任何蓄力的动作设计 <strong>↑</strong></p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E8%93%84%E5%8A%9B%E5%8A%A8%E4%BD%9C.gif\" alt=\"蓄力动作\"></p>\n<p>​\t\t\t\t\t这是添加了蓄力动作的设计 <strong>↑</strong></p>\n<p>​\t\t\t\t\t由此可见一个有节奏的动作设计需要在每帧内的速度各不相同，如果动画同学在进行动作设计的同时没有注意这\t\t\t\t\t点，很有可能导致最后动作设计缺少打击感。</p>\n<ul>\n<li>\n<p>需要有后摇缓冲</p>\n<p>对于一个攻击动作而言，无论其是否能被取消（<a href=\"#动作取消\">动作取消</a>），都需要设计其攻击判定结束后的收招动作，是确保动作的连贯性和演出性质的重要因素。同时搭配动作取消，能成为影响操作手感的重要因素。</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E5%8E%9F%E7%A5%9E%E6%94%B6%E5%89%91.gif\" alt=\"原神收剑\" title=\"原神迪卢克收剑动作\"></p>\n</li>\n</ul>\n</li>\n<li>\n<h4><span id=\"受击-动作\"> 受击 动作</span></h4>\n<ul>\n<li>\n<p>夸张化处理</p>\n<p>对于 videogame 而言，通常由于缺少大银幕、运镜、对焦等拍摄手法，其表现力通常不如影视作品，所以在游戏中的动作设计通常会比影视作品中更加夸张化处理一点。</p>\n</li>\n<li>\n<p>一帧切原则</p>\n<p>通常动作游戏的打击感强调爽快、精准和迅速的反馈，所以当角色受到攻击后，需要参考一帧切原则进行受击动画的播放。即：角色从当前动作过度到受击动作的播放只能使用一帧的过度时间</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E4%B8%80%E5%B8%A7%E5%88%87%E5%8E%9F%E5%88%99.gif\" alt=\"一帧切原则\" title=\"一帧切原则\"></p>\n<p>而在以强调真实感的拟真游戏当中，动作设计以真实感为核心，所以此时无需参考一帧切原则，可以使用较长的过渡动画。</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E5%88%87%E6%9E%AA%E5%A1%94%E7%A7%91%E5%A4%AB.gif\" alt=\"切枪塔科夫\"></p>\n</li>\n<li>\n<p>分档合理</p>\n<p>在 ARPG/ACT 游戏中，受击动作会根据规则进行分档</p>\n<ul>\n<li>\n<p>融合受击：不会打断角色当前的动作，通过动画遮罩实现受击动作和当前动作的融合。</p>\n</li>\n<li>\n<p>大 / 小受击：此类型受击会打断角色当前动作，通过一帧切播放受击动画来打断角色当前动作。</p>\n</li>\n<li>\n<p>击飞受击：角色受到重受击后，自身产生击飞类型的受击位移。</p>\n<p>通常重受击会投放在连段中的最后一段，符合战斗从压抑到释放的节奏，如果将重攻击投放在普攻中间，会导致连段无法连上，破坏玩家战斗节奏</p>\n</li>\n</ul>\n</li>\n<li>\n<p>动画融合</p>\n<p>以 unity 为例用动画层（layers）和动画遮罩（avatar mask）实现动画融合，可以提高受击动作流畅性</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231019084938968.png\" alt=\"image-20231019084938968\"></p>\n<p>通过在 unity 中新建新的动画 layer，在播放受击动画依照动画层级和权重进行动作播放</p>\n<p>例如：当角色的上半身碰撞盒受击时，Body 层的动作播放受击动作权重为 100%，而下半身通过播放权重 20%，通过 IK 实现动画的连贯性，避免出现上半身受击，而下半身动作很大的错误案例</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E4%B8%80%E5%B8%A7%E5%88%87%E5%8E%9F%E5%88%99.gif\" alt=\"一帧切原则\"></p>\n<p>以同样的例子可以看出，在街霸 6 中的实现就是如此，当角色上半身受击时、下半身动作幅度并不大</p>\n</li>\n<li>\n<p>体型衰减</p>\n<p>如果在游戏中都是人形 avatar 且体型相差不大的情况下可以不使用体型衰减（如 FTG），但对于出现体型不同的怪物，例如当正常体型的人形角色攻击大体型怪物时，会需要有相应的受击衰减，可通过<a href=\"#韧性机制\"> 韧性机制</a>进行受击判定</p>\n</li>\n<li>\n<p>受身动作</p>\n<p>当角色受到大幅度受击动作后，通常应该有一个受身动作，其节奏随游戏不同略有不同，在格斗游戏中，角色受击后的起身应该保持尽可能相同的帧数，确保玩家在面对不同角色的时候的战斗节奏不会发生太大的变化。</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E5%AE%88%E8%BA%AB%E5%8A%A8%E4%BD%9C.gif\" alt=\"守身动作\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"2位移\"> （2）位移</span></h3>\n<ul>\n<li>\n<h4><span id=\"受击位移\"> 受击位移</span></h4>\n<p>通常受击位移在前 4 帧内不会有太大变化，目的是配合特效生命周期进行统一管理，防止出现特效播放位置和实际受击位置不匹配的问题。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><img src=\"/images/Loading1.gif\" data-original=\"image-20231019093225842.png\" alt=\"image-20231019093225842\" style=\"zoom:33%;\"></th>\n<th><img src=\"/images/Loading1.gif\" data-original=\"image-20231019093247344.png\" alt=\"image-20231019093247344\" style=\"zoom:33%;\"></th>\n<th><img src=\"/images/Loading1.gif\" data-original=\"image-20231019093621101.png\" alt=\"image-20231019093621101\" style=\"zoom:33%;\"></th>\n</tr>\n</thead>\n</table>\n<p>由于受击位移在前 4 帧内不会发生较大变化，所以在初速度算法上会有额外的补偿，例如：</p>\n<p>设理论初速度 v=10m/s</p>\n<p>则补偿后的初速度 v1=10/(0.167*5)≈12m/s</p>\n</li>\n</ul>\n<h3><span id=\"3特效\"> （3）特效</span></h3>\n<ul>\n<li>\n<p>攻击特效</p>\n<p>攻击特效需要匹配角色战斗性能，即特效需要符合角色动作，避免出现动作不匹配的问题</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231019094253154.png\" alt=\"image-20231019094253154\"></p>\n</li>\n<li>\n<p>受击特效</p>\n<p>受击特效按类别又可以分为一下几类</p>\n<ul>\n<li>\n<p>通用受击特效</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/images/Loading1.gif\" data-original=\"%E8%A1%8C%E7%A7%8B.gif\" alt=\"行秋\"></th>\n<th><img src=\"/images/Loading1.gif\" data-original=\"%E5%8F%97%E5%87%BB%E7%89%B9%E6%95%88%E8%A1%8C%E7%A7%8B.png\" alt=\"受击特效行秋\"></th>\n</tr>\n</thead>\n</table>\n<p>此类型特效无需特殊的表现，都可以引用合适的受击特效，绝大多数近战和远程物理类型攻击可引用这些受击特效</p>\n</li>\n<li>\n<p>技能专用受击特效</p>\n<p>有时为了体现技能本身的特性，需要制作技能专用受击特效，可以弥补此类技能本身动作表现较弱的缺点</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"babara.gif\" alt=\"babara\"></p>\n</li>\n<li>\n<p>物体受击特效</p>\n<p>与技能受击特效不同，此类型的特效播放规则不依赖于攻击方的攻击方式，只取决于受击方的特性</p>\n<p>例如：</p>\n<ul>\n<li>\n<p>护盾受击</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E6%8A%A4%E7%9B%BE%E5%8F%97%E5%87%BB.gif\" alt=\"护盾受击\"></p>\n</li>\n<li>\n<p>场景受击</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E5%9C%BA%E6%99%AF%E5%8F%97%E5%87%BB.gif\" alt=\"场景受击\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>特效生命周期</p>\n<p>通常来说，一个特效的生命周期分为三个关键帧</p>\n<ul>\n<li>首帧表现：即特效的第一帧会达到总体的 80% 的表现</li>\n<li>最大形状帧数：在特效的第三帧会达到总体的 100%</li>\n<li>消散帧数：通常会在第 7-8 帧消散，视情况而定</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><img src=\"/images/Loading1.gif\" data-original=\"image-20231019095930979.png\" alt=\"image-20231019095930979\"></th>\n<th><img src=\"/images/Loading1.gif\" data-original=\"image-20231019095947453.png\" alt=\"image-20231019095947453\"></th>\n<th><img src=\"/images/Loading1.gif\" data-original=\"image-20231019100003310.png\" alt=\"image-20231019100003310\"></th>\n</tr>\n</thead>\n</table>\n</li>\n<li>\n<p>顿帧</p>\n<p>顿帧是一把双刃剑，在不合理的时候出现的顿帧会破坏游戏的整体流畅性，仅适合用在大型怪物或一些需要特别表现的受击动作上。</p>\n</li>\n</ul>\n<h3><span id=\"4ui-和后处理\"> （4）UI 和后处理</span></h3>\n<ul>\n<li>\n<p>伤害显示</p>\n<p>通过伤害显示的方式体现是否命中是一种简单的处理方式。</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"apex.gif\" alt=\"apex\"></p>\n</li>\n<li>\n<p>血条震动</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E8%A1%80%E6%9D%A1%E9%9C%87%E5%8A%A8.gif\" alt=\"血条震动\"></p>\n</li>\n<li>\n<p>屏幕震动</p>\n<p>屏幕震动同样是一把双刃剑，仅仅适合用在蓄力、重武器的攻击前摇以及命中等情况下，适合搭配镜头运动等其他因素一起食用。</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E9%9C%87%E5%B1%8F%E5%B9%95.gif\" alt=\"震屏幕\" title=\"图片来源于网络\"></p>\n</li>\n<li>\n<p>风格化处理</p>\n<p>风格化后处理是一种能快速表现攻击和受击的方式，但需要注意避免后处理过多导致遮挡主要画面。</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E9%A3%8E%E6%A0%BC%E5%8C%96%E5%A4%84%E7%90%86.gif\" alt=\"风格化处理\"></p>\n</li>\n<li>\n<p>特写镜头</p>\n<p>特写镜头是一种影视化的处理方式，能带来较好的表现</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E9%95%9C%E5%A4%B4.gif\" alt=\"镜头\"></p>\n</li>\n</ul>\n<hr>\n<h2><span id=\"2-听觉因素\"> 2、听觉因素</span></h2>\n<h3><span id=\"1音效\"> （1）音效</span></h3>\n<p>音效设计总体上可以确认是以下流程：</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E9%9F%B3%E6%95%88%E8%AE%BE%E8%AE%A1.png\" alt=\"音效设计\"></p>\n<ul>\n<li>\n<p>近战受击音效</p>\n<p>近战音效的受击是多方面的因素共同影响的，通过多方面的因素产生音效融合来体现打击感</p>\n<ul>\n<li>受击材质\n<ul>\n<li>肉体</li>\n<li>金属</li>\n<li>甲壳</li>\n</ul>\n</li>\n<li>攻击力度\n<ul>\n<li>轻攻击</li>\n<li>重攻击</li>\n</ul>\n</li>\n<li>攻击锋利度\n<ul>\n<li>锐器</li>\n<li>钝器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>远程受击音效</p>\n<p>远程受击音效通常是较为单层的，受击材质部分占据了大部分的权重</p>\n<ul>\n<li>\n<p>受击材质</p>\n</li>\n<li>\n<p>子弹口径</p>\n</li>\n<li>\n<p>子弹射速</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2><span id=\"3-输入因素\"> 3、输入因素</span></h2>\n<h3><span id=\"1判定\"> （1）判定</span></h3>\n<ul>\n<li>\n<p>碰撞盒</p>\n<p>对于任何一款拥有战斗元素的游戏来说，攻击的命中判定都是不可或缺的因素</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E7%A2%B0%E6%92%9E%E5%92%8C.png\" alt=\"碰撞和\"></p>\n<p>通常碰撞盒可以分为以下几类：</p>\n<ul>\n<li>矩形（通常用于 2D 游戏）</li>\n<li>球体</li>\n<li>胶囊体</li>\n<li>BOX</li>\n</ul>\n<p>在 3d 游戏中较多的使用胶囊体作为 hitbox，主要原因是胶囊体在引擎进行碰撞计算的时候会消耗更少的性能。</p>\n</li>\n<li>\n<p>碰撞判定</p>\n<p>主要是针对碰撞盒在攻击过程中产生的连续碰撞问题，因为在引擎中，碰撞是连续存在的，在攻击命中后，对于是否需要连续进行命中判定，就需要对技能进行提前设计。</p>\n<p>在技能编辑器中需要设计此功能，即在攻击招式的判定帧内生效次数。</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"d5b82012-0436-452c-a88e-4b150cb08059.png\" alt=\"d5b82012-0436-452c-a88e-4b150cb08059\" title=\"图片来源于网络\"></p>\n</li>\n<li>\n<p>位置判定</p>\n<p>通常受击位置的判定需要考虑攻击碰撞盒同时命中多个受击碰撞盒的问题。此时需要设计正确的碰撞规则，才能保证受击方的动作和特效播放正确。</p>\n<p>可以使用向量判定方案：即记录从攻击碰撞盒到每个受击碰撞盒中心位置的向量，记为判定向量 DisToBox。同时记录攻击方向向量 disAttack，则取两者向量差值最小时的碰撞盒为实际受击位置。</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231019103815644.png\" alt=\"image-20231019103815644\"></p>\n</li>\n<li>\n<p><dic id=\"韧性机制\">动作判定</dic></p>\n<p>通常在 ARPG/ACT 游戏中会有一套韧性判定机制，当韧性小于 0 时才会播放重受击动画。</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"image-20231019104122855.png\" alt=\"image-20231019104122855\"></p>\n</li>\n</ul>\n<h3><span id=\"2动作取消\"> <dic id=\"动作取消\">（2）动作取消</dic></span></h3>\n<p>动作取消在动作游戏中是一个很重要的因素</p>\n<p>首先，减少了收尾，两个技能的连接可以使得动作更加的顺滑，其次，减少了破绽，因为在起手和收尾阶段往往更容易受到攻击和打断，而攻击时往往处于难以打断状态。再者，某一个动作可能有更多的后续动作，拓宽了动作选择，达到出其不意的效果，让战局更加的变幻莫测。</p>\n<p>并且在不同类型的游戏中取消会有不同的设定：</p>\n<ul>\n<li>\n<p>Moba 中一般可以在攻击的任何时候取消</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"35169915-3d23-436d-b3d8-8895e6043e22.gif\" alt=\"35169915-3d23-436d-b3d8-8895e6043e22\"></p>\n</li>\n<li>\n<p>RPG 来说只能取消部分的后摇收招 动作</p>\n<img src=\"/images/Loading1.gif\" data-original=\"优菈.gif\" alt=\"优菈\" style=\"zoom: 25%;\">\n</li>\n<li>\n<p>FTG 中需要操作的指令覆盖或者消耗资源来强制取消</p>\n</li>\n</ul>\n<hr>\n<h2><span id=\"4-触觉因素\"> 4、触觉因素</span></h2>\n<p>触觉因素是一个和硬件关联性很大的因素，通常在主机游戏中体现较为明显，也更容易做适配。</p>\n<h3><span id=\"1控制器震动\"> （1）控制器震动</span></h3>\n<p>通常来说在命中时给控制器一个震动指令，能带给玩家更直观的打击体验</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"FF16.gif\" alt=\"FF16\" title=\"FF16泰坦boss战\"></p>\n<h3><span id=\"2力反馈扳机\"> （2）力反馈扳机</span></h3>\n<p>在 dualsecse 控制器中新增的力反馈扳机搭配 ps5 平台的专门主机优化，在一系列射击游戏中能获得更优秀的感官体验。</p>\n<hr>\n<p>暂时就会这么多，想到了再更新。欢迎各位大佬对文章有任何问题可以通过主页的联系方式联系我进行探讨。</p>\n",
            "tags": [
                "战斗"
            ]
        },
        {
            "id": "https://zeroruby.github.io/2023/10/15/%E7%94%9F%E5%8C%96%E5%8D%B1%E6%9C%BA4%E9%87%8D%E5%88%B6%E7%89%88%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/",
            "url": "https://zeroruby.github.io/2023/10/15/%E7%94%9F%E5%8C%96%E5%8D%B1%E6%9C%BA4%E9%87%8D%E5%88%B6%E7%89%88%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/",
            "title": "生化危机4重制版关卡设计分析",
            "date_published": "2023-10-14T16:00:00.000Z",
            "content_html": "<p>一篇关于分析生化危机 4 重制版中的部分关卡是如何控制玩家行动并创造恐怖氛围的。</p>\n<span id=\"more\"></span>\n<hr>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E4%B8%80-%E5%85%B3%E5%8D%A1%E6%A0%B8%E5%BF%83%E4%BD%93%E9%AA%8C\">一、关卡核心体验</a>\n<ul>\n<li><a href=\"#1-%E5%85%B3%E5%8D%A1%E4%B8%BB%E9%A2%98\">1、关卡主题</a></li>\n<li><a href=\"#2-%E5%85%B3%E5%8D%A1%E4%BD%93%E9%AA%8C\">2、关卡体验</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%8C-%E5%85%B3%E5%8D%A1%E7%8E%A9%E6%B3%95\">二、关卡玩法</a>\n<ul>\n<li><a href=\"#1-%E5%85%B3%E5%8D%A1%E5%85%83%E4%BB%B6\">1、关卡元件</a></li>\n<li><a href=\"#2-%E5%85%B3%E5%8D%A1%E7%9B%AE%E6%A0%87\">2、关卡目标</a></li>\n<li><a href=\"#3-%E5%85%B3%E5%8D%A1%E9%9A%BE%E5%BA%A6%E6%84%9F%E7%9F%A5\">3、关卡难度感知</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%89-%E5%85%B3%E5%8D%A1%E6%B5%81%E7%A8%8B%E5%9B%BE\">三、关卡流程图</a>\n<ul>\n<li><a href=\"#1-%E5%85%B3%E5%8D%A1%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90\">1、关卡流程解析</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9B%9B-%E5%85%B3%E5%8D%A1%E4%BF%AF%E8%A7%86%E5%9B%BE\">四、关卡俯视图</a></li>\n<li><a href=\"#%E4%BA%94-%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82\">五、关卡设计细节</a></li>\n<li><a href=\"#%E5%85%AD-%E5%85%B3%E5%8D%A1%E6%B5%81%E7%A8%8B%E8%A7%86%E9%A2%91\">六、关卡流程视频</a></li>\n</ul>\n<!-- tocstop -->\n<hr>\n<h2><span id=\"一-关卡核心体验\"> 一、关卡核心体验</span></h2>\n<h3><span id=\"1-关卡主题\"> 1、关卡主题</span></h3>\n<p>游戏中的舞台是欧洲一个被茂密森林包围的封闭村庄。有传言说这个村庄内存在着一个怪异的邪教。在村庄内有城堡、检查站、湖泊、庄园、农场、村庄广场、镇厅、养鱼场、教堂、采石场和废弃工厂等地点。</p>\n<p>而在村庄广场这个关卡中，主要向玩家揭露了这个邪教地方的一角，玩家会首次见到大量的僵尸，需要玩家仔细探索，小心前进才能进入下一关卡。在短短几分钟内就将玩家投入到一个充满敌意和压迫感的环境中，让玩家在没有过多教学和提示的情况下，快速掌握游戏的基本操作和战斗规律。</p>\n<h3><span id=\"2-关卡体验\"> 2、关卡体验</span></h3>\n<p>村庄广场这个关卡属于新手关卡的一部分，通过村庄广场关卡后，才能解锁商人系统进行更深度的角色养成并解锁更多的玩法。</p>\n<p>对于一周目的玩家来说，这个关卡难度较高，对于玩家探索场景的要求较高，需要玩家尽可能的收集场景中的装备并熟悉和邪教徒的战斗；而在此关卡之前，主要属于让玩家熟悉操作的新手教程部分。</p>\n<p>所以本关卡给予玩家的游戏体验是：</p>\n<p>●希望玩家迅速熟悉游戏的玩法（利用资源击败邪教徒、发现场景中的资源和道具）；</p>\n<p>●让玩家迅速熟悉游戏难度和部分系统；</p>\n<p>●让玩家感受到游戏的整体恐怖氛围基调；</p>\n<p>●带给玩家紧张刺激的战斗体验。</p>\n<p>于是在这样的关卡设计基调上，所有的设计都是围绕着恐怖氛围感和紧张的战斗。</p>\n<p>3、关卡定位</p>\n<p>以战斗体验为核心驱动玩家进行箱庭探索的关卡。</p>\n<h2><span id=\"二-关卡玩法\"> 二、关卡玩法</span></h2>\n<h3><span id=\"1-关卡元件\"> 1、关卡元件</span></h3>\n<p>●<a href=\"https://www.bilibili.com/video/BV1DY4y1D7CX?t=516.6\">可破坏物</a><br>\n如木桶、箱子等，破坏这些物体可以获得物资，并且物资投放是有游戏中的动态难度系统（DAS）决定的，设计师无需考虑每个箱子投放什么物品。</p>\n<p>●普通小钥匙：<br>\n和主线流程无关，主要用途为收集品的收集</p>\n<p>●<a href=\"https://www.bilibili.com/video/BV1DY4y1D7CX?t=693.7\">邪教徒：</a><br>\n关卡的核心敌人，从对关卡结构的影响程度来看，分为不移动的怪物和巡逻型怪物。并且关卡核心玩法在被敌人发现前后从潜行式的探索玩法转变为战斗为核心的射击玩法。</p>\n<p>●<a href=\"https://www.bilibili.com/video/BV1DY4y1D7CX?t=254.5\">主线相关物品:</a><br>\n 与主线相关的道具，必须获得该道具才能进入下一箱庭，属于对关卡流程影响较大的\t物品。</p>\n<p>●场景交互道具：<br>\n○<a href=\"https://www.bilibili.com/video/BV1DY4y1D7CX?t=838.1\">门</a><br>\n○<a href=\"https://www.bilibili.com/video/BV1DY4y1D7CX?t=854.3\">书柜</a><br>\n○<a href=\"https://www.bilibili.com/video/BV1DY4y1D7CX?t=866.5\">梯子</a><br>\n○<a href=\"https://www.bilibili.com/video/BV1DY4y1D7CX?t=807.2\">牛棚</a></p>\n<h3><span id=\"2-关卡目标\"> 2、关卡目标</span></h3>\n<p>村庄广场的目标是与邪教徒战斗，击杀一定数量的敌人或在围攻中坚持 5 分钟，直到教堂钟声敲响。</p>\n<h3><span id=\"3-关卡难度感知\"> 3、关卡难度感知</span></h3>\n<p>在《生化危机 4 重制版》中采用了动态的难度系统，将根据玩家的表现水平、玩家的当前资源量进行评估，对接下来投放的资源进行调整。<br>\n通过动态难度系统，玩家在关卡中对难度的感知会始终保持在较高的水平。<br>\n以村庄广场为例分析该关卡的难度流曲线如图：<br>\n<img src=\"/images/Loading1.gif\" data-original=\"%E5%BF%83%E6%B5%81.png\" alt=\"这是图片\"></p>\n<h2><span id=\"三-关卡流程图\"> 三、关卡流程图</span></h2>\n<h3><span id=\"1-关卡流程解析\"> 1、关卡流程解析</span></h3>\n<p>在进入村庄广场关卡后，会有一个道路选择，而左边的道路带给玩家更多的安全感，所以一周目的玩家大部分会选择左边的道路。<br>\n<a href=\"https://www.bilibili.com/video/BV1DY4y1D7CX?t=713.8\">https://www.bilibili.com/video/BV1DY4y1D7CX?t=713.8</a></p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E6%B5%81%E7%A8%8B1.png\" alt=\"流程1\"></p>\n<p>这里主要分析正常流程。</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E6%B5%81%E7%A8%8B2.png\" alt=\"流程2\"></p>\n<p>在这个流程中，主要分为两个阶段：未被敌人发现的阶段 和 被敌人发现的阶段，两个阶段的关卡目标有所不同。<br>\n在未被发现的阶段中，玩家的行动区域较为固定，超过这个安全区域的地方会被敌人发现并进入战斗阶段。<br>\n在战斗阶段中，需要玩家充分利用场景物件与邪教徒战斗。并且场景中有许多关卡元件用于辅助玩家战斗。<br>\n流程回归：在关卡设计中可以通过多路线选择设计出不同的玩家动线，但是在生化危机 4 中，即使采用了多路径的设计，最终玩家都会回归到战斗流程中，即战斗流程为关卡核心</p>\n<h2><span id=\"四-关卡俯视图\"> 四、关卡俯视图</span></h2>\n<p>蓝线为玩家在未被发现时的行动路线，由于关卡目标需要经过战斗，所以所有的玩家动线最终都离不开战斗。</p>\n<p><img src=\"/images/Loading1.gif\" data-original=\"%E4%BF%AF%E8%A7%86%E5%9B%BE.png\" alt=\"俯视图\"></p>\n<h2><span id=\"五-关卡设计细节\"> 五、关卡设计细节</span></h2>\n<p>1、关卡引导<br>\n●难度引导：在进入关卡时，主路有大量邪教徒敌人，对于当前玩家缺少武器和弹药的情况下，直接进入战斗很明显会对玩家有较大的难度，因此引导玩家进入不会被敌人发现的右边的小路。</p>\n<p>●视觉引导：<br>\n关卡中有大量诸如窗户、楼梯等场景元件用于进行视觉引导，引导玩家进入房间或使\t用梯子进行探索或辅助战斗</p>\n<p>●奖励指引：<br>\n关卡中投放了许多能用于投放资源的可破坏物体，这些在战斗过程中一定程度的引导\t玩家的行动路线</p>\n<p>2、关于关卡是如何营造恐怖氛围感</p>\n<p>●视觉<br>\n游戏中无论是邪教徒诡异的行为还是环境中大量的刑具、断肢等等都是营造恐怖分为\t的重要因素</p>\n<p>●音效<br>\n游戏中邪教徒发出的声音让玩家身临其境的感知到邪教徒的诡异从而营造恐怖氛围感</p>\n<p>●战斗中的 AI 设计<br>\n在战斗过程中，关卡中的敌人会逐渐包围你，玩家必须迅速做出突围决定，如果玩家进入了小巷等狭窄空间时，会带来较强的刺激感和恐怖氛围。</p>\n<p>●高难度的关卡流程（核心）<br>\n游戏的关卡难度都较高，例如较少的弹药资源和医疗物品，因此较高的关卡难度也塑造了真实的恐怖氛围。<br>\n通过玩家的弱势地位和怪物的强势地位的差异营造出较强的恐怖氛围感。</p>\n<h2><span id=\"六-关卡流程视频\"> 六、关卡流程视频</span></h2>\n<p>1、正常流程<br>\n<a href=\"https://www.bilibili.com/video/BV1DY4y1D7CX?t=682.5\"> https://www.bilibili.com/video/BV1DY4y1D7CX?t=682.5</a></p>\n<p>2、速通流程<br>\n<a href=\"https://www.bilibili.com/video/BV1D84y1T7Nn/?spm_id_from=333.337.search-card.all.click\"> https://www.bilibili.com/video/BV1D84y1T7Nn/?spm_id_from=333.337.search-card.all.click</a></p>\n<p>3、手残流程<br>\n<a href=\"https://www.bilibili.com/video/BV1oP411d7Y2/?spm_id_from=333.337.search-card.all.click\"> https://www.bilibili.com/video/BV1oP411d7Y2/?spm_id_from=333.337.search-card.all.click</a></p>\n",
            "tags": [
                "关卡"
            ]
        }
    ]
}